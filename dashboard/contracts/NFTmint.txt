// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./IAffiliateTracker.sol";

contract NFTMint is ERC721, ERC721Burnable, Ownable, ReentrancyGuard {
    struct Affiliate {
        bool instantDirectPayment;
    }
    // Define a struct to store royalty information
    struct RoyaltyInfo {
        uint256 percentage; // Royalty percentage
        address creator;    // Address of the NFT creator
    }

    uint256 private _tokenIdCounter = 1;
    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => uint256) public tokenPrices;
    mapping(uint256 => address) public tokenSellers;
    mapping(uint256 => uint256) public nftCommissionRates;
    mapping(address => Affiliate) public affiliates;
    mapping(uint256 => RoyaltyInfo) public royaltyInfo;


    IAffiliateTracker public affiliateTracker;

    uint256 public defaultCommissionRate = 10;
    address public defaultAffiliate;

    event TokenSold(uint256 indexed tokenId, address indexed buyer, uint256 salePrice);
    event NFTListed(uint256 indexed tokenId, string uri, uint256 price);
    event AffiliateRegistered(address indexed affiliate, uint256 commissionRate);
    event AffiliateRevoked(address indexed affiliate);
    event CommissionPaid(address indexed affiliate, uint256 amount, uint256 tokenId);
    event DirectPaymentToggled(address indexed affiliate, bool isEnabled);
    event CommissionRateUpdated(address indexed affiliate, uint256 newRate);
    event NFTCommissionRateSet(uint256 indexed tokenId, uint256 commissionRate);
    // Event to log royalty settings
    event RoyaltySet(uint256 indexed tokenId, uint256 percentage, address indexed creator);
    // Event to log royalty payments
    event RoyaltyPaid(address indexed creator, uint256 amount, uint256 tokenId);
    event NFTMinted(uint256 indexed tokenId, address indexed creator, string tokenURI);



    constructor(string memory name, string memory symbol, address _affiliateTrackerAddress)
    ERC721(name, symbol)
    Ownable(msg.sender) // Pass the deployer's address as the initial owner
{
    affiliateTracker = IAffiliateTracker(_affiliateTrackerAddress);
}

    // Function to set royalty for a specific NFT
    function setRoyalty(uint256 tokenId, uint256 percentage, address creator) public onlyOwner {
        require(percentage <= 100, "Royalty percentage cannot exceed 100");
        royaltyInfo[tokenId] = RoyaltyInfo(percentage, creator);
        emit RoyaltySet(tokenId, percentage, creator);
    }

    function setNFTCommissionRate(uint256 tokenId, uint256 newCommissionRate) public {
        address tokenOwner = ownerOf(tokenId);
        require(
            msg.sender == tokenOwner ||
            getApproved(tokenId) == msg.sender ||
            isApprovedForAll(tokenOwner, msg.sender),
            "Caller is not owner nor approved"
        );
        require(newCommissionRate <= 100, "Commission rate cannot exceed 100");
        nftCommissionRates[tokenId] = newCommissionRate;
        emit NFTCommissionRateSet(tokenId, newCommissionRate);
    }

    function buyNFT(uint256 tokenId, address affiliate) public payable nonReentrant {
        require(msg.value >= tokenPrices[tokenId], "Payment is below the price");
        require(bytes(_tokenURIs[tokenId]).length != 0, "Token not for sale");

        uint256 salePrice = msg.value;
        uint256 commissionRateForNFT = nftCommissionRates[tokenId] > 0 ? nftCommissionRates[tokenId] : defaultCommissionRate;
        uint256 commission = calculateCommission(salePrice, commissionRateForNFT);

        delete _tokenURIs[tokenId];
        delete tokenPrices[tokenId];
        delete tokenSellers[tokenId];

        payable(tokenSellers[tokenId]).transfer(salePrice - commission);

        // Pay royalties to the creator
        payRoyalty(tokenId, salePrice);

        // Pay commission to the affiliate
        if (commission > 0) {
            if (affiliate != address(0)) {
                affiliateTracker.payCommission(affiliate, salePrice, address(this), tokenId);
            } else {
                affiliateTracker.payCommission(defaultAffiliate, salePrice, address(this), tokenId);
            }
        }

        _safeMint(msg.sender, tokenId);
        emit TokenSold(tokenId, msg.sender, salePrice);
    }

    // Function to calculate and pay royalties upon NFT sale
    function payRoyalty(uint256 tokenId, uint256 salePrice) internal {
        RoyaltyInfo memory royalty = royaltyInfo[tokenId];
        require(royalty.creator != address(0), "Royalty not set for this NFT");

        uint256 royaltyAmount = (salePrice * royalty.percentage) / 100;
        payable(royalty.creator).transfer(royaltyAmount);
        emit RoyaltyPaid(royalty.creator, royaltyAmount, tokenId);
    }

    function calculateCommission(uint256 _salePrice, uint256 _rate) public pure returns (uint256) {
        return (_salePrice * _rate) / 100;
    }

    function setDefaultAffiliate(address affiliate) public onlyOwner {
        defaultAffiliate = affiliate;
    }

    function setDefaultCommissionRate(uint256 newRate) public onlyOwner {
        require(newRate >= 1 && newRate <= 100, "Invalid commission rate");
        defaultCommissionRate = newRate;
    }

    function setAffiliateCommissionRate(address affiliate, uint256 newRate) public onlyOwner {
        require(newRate >= 1 && newRate <= 100, "Invalid commission rate");
        affiliateTracker.setCommissionRate(affiliate, newRate);
        emit CommissionRateUpdated(affiliate, newRate);
    }

    function registerAffiliate(address newAffiliateAddress, uint256 newCommissionRate) public onlyOwner {
        affiliateTracker.registerAffiliate(newAffiliateAddress, newCommissionRate);
        emit AffiliateRegistered(newAffiliateAddress, newCommissionRate);
    }

    function revokeAffiliate(address affiliate) public onlyOwner {
        affiliateTracker.revokeAffiliate(affiliate);
        emit AffiliateRevoked(affiliate);
    }

    function setInstantDirectPayment(address affiliate, bool allowInstantDirectPayment) public onlyOwner {
        affiliates[affiliate].instantDirectPayment = allowInstantDirectPayment;
        emit DirectPaymentToggled(affiliate, allowInstantDirectPayment);
    }

    function toggleDirectPaymentGlobal() public onlyOwner {
        bool isEnabled = affiliateTracker.isDirectPaymentEnabled();
        affiliateTracker.toggleDirectPaymentGlobal();
        emit DirectPaymentToggled(address(0), !isEnabled);
    }

    function toggleDirectPaymentUser(address affiliate) public onlyOwner {
        bool currentState = affiliates[affiliate].instantDirectPayment;
        affiliates[affiliate].instantDirectPayment = !currentState;
        emit DirectPaymentToggled(affiliate, !currentState);
    }

    function allowContract(address _contract) public onlyOwner {
        affiliateTracker.allowContract(_contract);
    }

    function setAffiliateTrackerAddress(address _affiliateTrackerAddress) public onlyOwner {
        affiliateTracker = IAffiliateTracker(_affiliateTrackerAddress);
    }

    function listNFTForSale(string memory uri, uint256 price) public {
        require(msg.sender != address(0), "Invalid address");
        uint256 tokenId = _tokenIdCounter++;
        _tokenURIs[tokenId] = uri;
        tokenPrices[tokenId] = price;
        tokenSellers[tokenId] = msg.sender;
        emit NFTListed(tokenId, uri, price);
    }

    function tokenExists(uint256 tokenId) public view returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(tokenExists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return string(abi.encodePacked(_baseURI(), _tokenURIs[tokenId]));
    }

    receive() external payable {}

    fallback() external payable {}
}
