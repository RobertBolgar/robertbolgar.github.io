// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "./IAffiliateTracker.sol"; // Ensure this path is correct



contract NFTMint is ERC721, ERC721Burnable, Ownable(msg.sender) {
    using SafeMath for uint256;

    // Affiliate struct to store whether instant direct payments are allowed
    struct Affiliate {
        bool instantDirectPayment;
    }

    uint256 private _tokenIdCounter = 1;
    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => uint256) public tokenPrices;
    mapping(uint256 => address) public tokenSellers;

    // Mapping of affiliate address to Affiliate struct
    mapping(address => Affiliate) public affiliates;
    mapping(address => uint256) public affiliateCommissionRates;
    mapping(address => uint256) public affiliateEarnings;


    IAffiliateTracker public affiliateTracker;

    uint256 public commissionRate = 10; // Default commission rate
    bool public emergencyStop = false;

    event TokenSold(uint256 indexed tokenId, address indexed buyer, uint256 salePrice);
    event NFTListed(uint256 indexed tokenId, string uri, uint256 price);
    event EmergencyStopActivated(bool status);

    constructor(string memory name, string memory symbol, address _affiliateTrackerAddress)
    ERC721(name, symbol) {
        affiliateTracker = IAffiliateTracker(_affiliateTrackerAddress);
    }

    address public defaultAffiliate;
    uint256 public defaultCommissionRate = 10; // Default commission rate

    // Function to set the default affiliate
    function setDefaultAffiliate(address affiliate) public onlyOwner {
        defaultAffiliate = affiliate;
    }

    // Function to set the default commission rate
    function setDefaultCommissionRate(uint256 newRate) public onlyOwner {
        require(newRate >= 1 && newRate <= 100, "Invalid commission rate");
        defaultCommissionRate = newRate;
    }

    // Function to set or update the commission rate for a specific affiliate
    function setAffiliateCommissionRate(address affiliate, uint256 newRate) public onlyOwner {
        require(newRate >= 1 && newRate <= 100, "Invalid commission rate");
        affiliateCommissionRates[affiliate] = newRate;
    }

    // Modify withdrawEarnings to allow only non-instant direct payment affiliates to withdraw
function withdrawEarnings() external view {
        require(!affiliates[msg.sender].instantDirectPayment, "Instant direct payment affiliates cannot withdraw earnings");
        // Withdraw earnings logic remains the same
    }

    // Function to grant or revoke instant direct payment privileges to affiliates
    function setInstantDirectPayment(address affiliate, bool allowInstantDirectPayment) public onlyOwner {
        affiliates[affiliate].instantDirectPayment = allowInstantDirectPayment;
    }

    function setAffiliateTrackerAddress(address _affiliateTrackerAddress) public onlyOwner {
        affiliateTracker = IAffiliateTracker(_affiliateTrackerAddress);
    }

    // Registers an affiliate with a specific commission rate
function registerAffiliate(address newAffiliateAddress, uint256 newCommissionRate) public onlyOwner {
    affiliateTracker.registerAffiliate(newAffiliateAddress, newCommissionRate);
}



// Revokes an affiliate
function revokeAffiliate(address affiliate) public onlyOwner {
    // Assuming AffiliateTracker has a revokeAffiliate function
    affiliateTracker.revokeAffiliate(affiliate);
}

// Toggles the global setting for direct payments
function toggleDirectPaymentGlobal() public onlyOwner {
    affiliateTracker.toggleDirectPaymentGlobal();
}

// Toggles direct payment for a specific affiliate
function toggleDirectPaymentUser(address affiliate) public onlyOwner {
    affiliateTracker.toggleDirectPaymentUser(affiliate);
}

// Sets or updates the commission rate for an affiliate
function setCommissionRate(address affiliate, uint256 newRate) public onlyOwner {
    affiliateTracker.setCommissionRate(affiliate, newRate);
}

// Allows a contract to call `payCommission`
function allowContract(address _contract) public onlyOwner {
    affiliateTracker.allowContract(_contract);
}


    function listNFTForSale(string memory uri, uint256 price) public {
        require(msg.sender != address(0), "Invalid address");
        uint256 tokenId = _tokenIdCounter++;
        _tokenURIs[tokenId] = uri;
        tokenPrices[tokenId] = price;
        tokenSellers[tokenId] = msg.sender;
        emit NFTListed(tokenId, uri, price);
    }

    function buyNFT(uint256 tokenId, address affiliate) public payable {
        require(msg.value >= tokenPrices[tokenId], "Payment is below the price");
        require(bytes(_tokenURIs[tokenId]).length != 0, "Token not for sale");
        require(!emergencyStop, "Sales are currently stopped");

        uint256 salePrice = msg.value;
        uint256 commission = salePrice.mul(commissionRate).div(100);
        uint256 sellerProceeds = salePrice.sub(commission);

        payable(tokenSellers[tokenId]).transfer(sellerProceeds);
        if (commission > 0) {
            affiliateTracker.payCommission(affiliate, commission, address(this), tokenId);
        }

        _safeMint(msg.sender, tokenId);
        emit TokenSold(tokenId, msg.sender, salePrice);

        // Cleanup
        delete _tokenURIs[tokenId];
        delete tokenPrices[tokenId];
        delete tokenSellers[tokenId];
    }

    function setEmergencyStop(bool status) public onlyOwner {
        emergencyStop = status;
        emit EmergencyStopActivated(status);
    }

function tokenExists(uint256 tokenId) public view returns (bool) {
    return _ownerOf(tokenId) != address(0);
}


    // Function to return the token URI for a given token ID
function tokenURI(uint256 tokenId) public view override returns (string memory) {
    require(tokenExists(tokenId), "ERC721Metadata: URI query for nonexistent token");

    return string(abi.encodePacked(_baseURI(), _tokenURIs[tokenId]));
}


    receive() external payable {}
    fallback() external payable {}
}
