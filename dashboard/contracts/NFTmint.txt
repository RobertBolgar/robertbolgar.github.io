// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./IAffiliateTracker.sol";

contract NFTMint is ERC721, ERC721Burnable, Ownable(msg.sender) {
    struct Affiliate {
        bool instantDirectPayment;
    }

    uint256 private _tokenIdCounter = 1;
    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => uint256) public tokenPrices;
    mapping(uint256 => address) public tokenSellers;
    mapping(uint256 => uint256) public nftCommissionRates;
    mapping(address => Affiliate) public affiliates;
    mapping(address => uint256) public affiliateCommissionRates;
    mapping(address => uint256) public affiliateEarnings;

    IAffiliateTracker public affiliateTracker;

    uint256 public commissionRate = 10;
    bool public emergencyStop = false;

    address public defaultAffiliate;
    uint256 public defaultCommissionRate = 10;

    event TokenSold(uint256 indexed tokenId, address indexed buyer, uint256 salePrice);
    event NFTListed(uint256 indexed tokenId, string uri, uint256 price);
    event EmergencyStopActivated(bool status);
    event AffiliateRegistered(address indexed affiliate, uint256 commissionRate);
    event AffiliateRevoked(address indexed affiliate);
    event CommissionPaid(address indexed affiliate, uint256 amount, uint256 tokenId);
    event DirectPaymentToggled(bool isEnabled);
    event CommissionRateUpdated(address indexed affiliate, uint256 newRate);
    event NFTCommissionRateSet(uint256 indexed tokenId, uint256 commissionRate);

    constructor(string memory name, string memory symbol, address _affiliateTrackerAddress)
    ERC721(name, symbol) {
        affiliateTracker = IAffiliateTracker(_affiliateTrackerAddress);
    }

    function setNFTCommissionRate(uint256 tokenId, uint256 newCommissionRate) public {
        address tokenOwner = ownerOf(tokenId);
        require(
            _msgSender() == tokenOwner ||
            getApproved(tokenId) == _msgSender() ||
            isApprovedForAll(tokenOwner, _msgSender()),
            "Caller is not owner nor approved"
        );
        require(newCommissionRate <= 100, "Commission rate cannot exceed 100");
        nftCommissionRates[tokenId] = newCommissionRate;
        emit NFTCommissionRateSet(tokenId, newCommissionRate);
    }

    function buyNFT(uint256 tokenId, address affiliate) public payable {
        require(msg.value >= tokenPrices[tokenId], "Payment is below the price");
        require(bytes(_tokenURIs[tokenId]).length != 0, "Token not for sale");
        require(!emergencyStop, "Sales are currently stopped");

        uint256 salePrice = msg.value;
        uint256 commissionRateForNFT = nftCommissionRates[tokenId];
        uint256 commission = (salePrice * commissionRateForNFT) / 100;
        uint256 sellerProceeds = salePrice - commission;

        payable(tokenSellers[tokenId]).transfer(sellerProceeds);
        if (commission > 0) {
            affiliateTracker.payCommission(affiliate, commission, address(this), tokenId);
        }

        _safeMint(msg.sender, tokenId);
        emit TokenSold(tokenId, msg.sender, salePrice);

        delete _tokenURIs[tokenId];
        delete tokenPrices[tokenId];
        delete tokenSellers[tokenId];
    }

    function setDefaultAffiliate(address affiliate) public onlyOwner {
        defaultAffiliate = affiliate;
    }

    function setDefaultCommissionRate(uint256 newRate) public onlyOwner {
        require(newRate >= 1 && newRate <= 100, "Invalid commission rate");
        defaultCommissionRate = newRate;
    }

    function setAffiliateCommissionRate(address affiliate, uint256 newRate) public onlyOwner {
        require(newRate >= 1 && newRate <= 100, "Invalid commission rate");
        affiliateCommissionRates[affiliate] = newRate;
    }

    function payCommission(address affiliate, uint256 amount, uint256 tokenId) external {
        affiliateEarnings[affiliate] += amount;
        emit CommissionPaid(affiliate, amount, tokenId);
    }

    function withdrawEarnings() external view {
        require(!affiliates[msg.sender].instantDirectPayment, "Instant direct payment affiliates cannot withdraw earnings");
    }

    function setInstantDirectPayment(address affiliate, bool allowInstantDirectPayment) public onlyOwner {
        affiliates[affiliate].instantDirectPayment = allowInstantDirectPayment;
    }

    function setAffiliateTrackerAddress(address _affiliateTrackerAddress) public onlyOwner {
        affiliateTracker = IAffiliateTracker(_affiliateTrackerAddress);
    }

    function registerAffiliate(address newAffiliateAddress, uint256 newCommissionRate) public onlyOwner {
        affiliateTracker.registerAffiliate(newAffiliateAddress, newCommissionRate);
        emit AffiliateRegistered(newAffiliateAddress, newCommissionRate);
    }

    function revokeAffiliate(address affiliate) public onlyOwner {
        affiliateTracker.revokeAffiliate(affiliate);
        emit AffiliateRevoked(affiliate);
    }

    function toggleDirectPaymentGlobal() public onlyOwner {
        affiliateTracker.toggleDirectPaymentGlobal();
    }

    function toggleDirectPaymentUser(address affiliate) public onlyOwner {
        affiliateTracker.toggleDirectPaymentUser(affiliate);
    }

    function setCommissionRate(address affiliate, uint256 newRate) public onlyOwner {
        affiliateTracker.setCommissionRate(affiliate, newRate);
    }

    function allowContract(address _contract) public onlyOwner {
        affiliateTracker.allowContract(_contract);
    }

    function listNFTForSale(string memory uri, uint256 price) public {
        require(msg.sender != address(0), "Invalid address");
        uint256 tokenId = _tokenIdCounter++;
        _tokenURIs[tokenId] = uri;
        tokenPrices[tokenId] = price;
        tokenSellers[tokenId] = msg.sender;
        emit NFTListed(tokenId, uri, price);
    }

    function setEmergencyStop(bool status) public onlyOwner {
        emergencyStop = status;
        emit EmergencyStopActivated(status);
    }

    function tokenExists(uint256 tokenId) public view returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(tokenExists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return string(abi.encodePacked(_baseURI(), _tokenURIs[tokenId]));
    }

    receive() external payable {}

    fallback() external payable {}
}
