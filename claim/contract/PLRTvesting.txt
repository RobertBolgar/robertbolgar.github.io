// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract PLRTVesting is Ownable, ReentrancyGuard, Pausable {
    IERC20 public plrtToken;

    struct VestingSchedule {
        uint256 start;
        uint256 totalAllocation;
        uint256 claimedAmount;
        uint256 lastClaimTime;
    }

    mapping(address => VestingSchedule) public teamVestingSchedules;
    mapping(address => VestingSchedule) public privateSaleNFTVestingSchedules;
    VestingSchedule public treasuryVestingSchedule;

    address[] public teamMemberKeys;
    address[] public privateSaleNFTKeys;

    address public treasuryWallet;

    uint256 public constant MAX_TREASURY_ALLOCATION = 10_000_000 * (10 ** 18);
    uint256 public constant MAX_TEAM_ALLOCATION = 15_000_000 * (10 ** 18);
    uint256 public constant MAX_PRIVATE_SALE_ALLOCATION = 5_000_000 * (10 ** 18);
    uint256 public constant REQUIRED_TOKEN_AMOUNT = 30_000_000 * (10 ** 18);

    uint256 public constant cliffDuration = 30 days;
    uint256 public constant vestingDuration = 7 days;

    event TokensClaimed(address indexed claimant, uint256 amountClaimed, uint256 timestamp);
    event TokensReceived(address from, uint256 amount);
    event VestingInitialized(address indexed beneficiary, uint256 totalAllocation, uint256 startTime);
    event VestingStarted(uint256 startTime);

    constructor(address _plrtToken) Ownable(_msgSender()) {
    require(_plrtToken != address(0), "PLRT token address cannot be 0");
    plrtToken = IERC20(_plrtToken);
}


    function setTreasuryWallet(address _treasuryWallet) external onlyOwner {
        require(_treasuryWallet != address(0), "Invalid treasury wallet address");
        treasuryWallet = _treasuryWallet;
    }

    function setTeamMemberVestingSchedule(address teamMember, uint256 totalAllocation) external onlyOwner {
        require(totalAllocation <= MAX_TEAM_ALLOCATION, "Exceeds max team member allocation");

        teamVestingSchedules[teamMember] = VestingSchedule({
            start: block.timestamp,
            totalAllocation: totalAllocation,
            claimedAmount: 0,
            lastClaimTime: block.timestamp
        });

        require(plrtToken.transferFrom(msg.sender, address(this), totalAllocation), "Failed to receive team tokens");

        emit TokensReceived(msg.sender, totalAllocation);

        if (!isTeamMember(teamMember)) {
            teamMemberKeys.push(teamMember);
        }
    }

    function setPrivateSaleNFTVestingSchedule(address nftHolder) external onlyOwner {
    require(MAX_PRIVATE_SALE_ALLOCATION > 0, "MAX_PRIVATE_SALE_ALLOCATION not set");

    // Ensure individual allocation doesn't exceed 1 million tokens
    uint256 totalAllocation = 1_000_000 * (10 ** 18);

    privateSaleNFTVestingSchedules[nftHolder] = VestingSchedule({
        start: block.timestamp,
        totalAllocation: totalAllocation,
        claimedAmount: 0,
        lastClaimTime: block.timestamp
    });

    require(plrtToken.transferFrom(msg.sender, address(this), totalAllocation), "Failed to receive NFT holder tokens");

    emit TokensReceived(msg.sender, totalAllocation);

    if (!isPrivateSaleNFTHolder(nftHolder)) {
        privateSaleNFTKeys.push(nftHolder);
    }
}

    function withdrawUnclaimedTokens() external onlyOwner {
    // Calculate the total unclaimed tokens for private sale NFT holders
    uint256 totalUnclaimedTokens = 0;
    for (uint256 i = 0; i < privateSaleNFTKeys.length; i++) {
        address holder = privateSaleNFTKeys[i];
        VestingSchedule memory schedule = privateSaleNFTVestingSchedules[holder];
        totalUnclaimedTokens += schedule.totalAllocation - schedule.claimedAmount;
    }

    // Transfer unclaimed tokens back to owner
    require(plrtToken.transfer(owner(), totalUnclaimedTokens), "Failed to transfer unclaimed tokens to owner");

    // Emit event
    emit TokensClaimed(owner(), totalUnclaimedTokens, block.timestamp);
}


    function setTreasuryVestingSchedule(uint256 totalAllocation) external onlyOwner {
        require(totalAllocation > 0, "Total allocation must be greater than zero");
        require(treasuryVestingSchedule.totalAllocation == 0, "Treasury vesting schedule already set");

        treasuryVestingSchedule = VestingSchedule({
            start: block.timestamp,
            totalAllocation: totalAllocation,
            claimedAmount: 0,
            lastClaimTime: block.timestamp
        });

        require(plrtToken.transferFrom(msg.sender, address(this), totalAllocation), "Failed to receive treasury tokens");

        emit TokensReceived(msg.sender, totalAllocation);
    }

    function getTeamMemberVestingDetails(address teamMember) external view returns (uint256, uint256, uint256) {
        VestingSchedule memory schedule = teamVestingSchedules[teamMember];
        return (schedule.totalAllocation, schedule.claimedAmount, calculateRemainingClaimableAmount(schedule));
    }

    function getPrivateSaleNFTVestingDetails(address nftHolder) external view returns (uint256, uint256, uint256) {
        VestingSchedule memory schedule = privateSaleNFTVestingSchedules[nftHolder];
        return (schedule.totalAllocation, schedule.claimedAmount, calculateRemainingClaimableAmount(schedule));
    }

    function getTreasuryVestingDetails() external view returns (uint256, uint256, uint256) {
        return (treasuryVestingSchedule.totalAllocation, treasuryVestingSchedule.claimedAmount, calculateRemainingClaimableAmount(treasuryVestingSchedule));
    }

    function calculateRemainingClaimableAmount(VestingSchedule memory schedule) internal view returns (uint256) {
        if (block.timestamp < schedule.start + cliffDuration) {
            return 0;
        }

        uint256 elapsedTime = block.timestamp - (schedule.start + cliffDuration);
        uint256 elapsedWeeks = elapsedTime / vestingDuration;
        uint256 claimableAmount = (schedule.totalAllocation / 10) * elapsedWeeks;

        if (claimableAmount > schedule.totalAllocation) {
            claimableAmount = schedule.totalAllocation;
        }

        uint256 remainingBalance = schedule.totalAllocation - schedule.claimedAmount;
        if (claimableAmount > remainingBalance) {
            claimableAmount = remainingBalance;
        }

        return claimableAmount;
    }

    function claimTokens() public {
        VestingSchedule storage schedule = teamVestingSchedules[msg.sender];
        require(schedule.totalAllocation > 0, "No vesting schedule found.");

        uint256 claimableAmount = calculateRemainingClaimableAmount(schedule);
        require(claimableAmount > 0, "No tokens available for claim.");

        schedule.claimedAmount += claimableAmount;
        require(plrtToken.transfer(msg.sender, claimableAmount), "Token transfer failed.");

        emit TokensClaimed(msg.sender, claimableAmount, block.timestamp);
    }

    function isTeamMember(address addr) public view returns (bool) {
        for (uint256 i = 0; i < teamMemberKeys.length; i++) {
            if (teamMemberKeys[i] == addr) {
                return true;
            }
        }
        return false;
    }

    function isPrivateSaleNFTHolder(address addr) public view returns (bool) {
        for (uint256 i = 0; i < privateSaleNFTKeys.length; i++) {
            if (privateSaleNFTKeys[i] == addr) {
                return true;
            }
        }
        return false;
    }


function claimPrivateSaleNFTTokens() public {
    VestingSchedule storage schedule = privateSaleNFTVestingSchedules[msg.sender];
    require(schedule.totalAllocation > 0, "No vesting schedule found for private sale NFT holder.");
    uint256 claimableAmount = calculateRemainingClaimableAmount(schedule);
    require(claimableAmount > 0, "No tokens available for claim.");
    schedule.claimedAmount += claimableAmount;
    require(plrtToken.transfer(msg.sender, claimableAmount), "Token transfer failed.");
    emit TokensClaimed(msg.sender, claimableAmount, block.timestamp);
}

function claimTreasuryTokens() public {
    VestingSchedule storage schedule = treasuryVestingSchedule;
    require(schedule.totalAllocation > 0, "No treasury vesting schedule found.");
    uint256 claimableAmount = calculateRemainingClaimableAmount(schedule);
    require(claimableAmount > 0, "No tokens available for claim.");
    schedule.claimedAmount += claimableAmount;
    require(plrtToken.transfer(treasuryWallet, claimableAmount), "Token transfer failed.");
    emit TokensClaimed(treasuryWallet, claimableAmount, block.timestamp);
}

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}
