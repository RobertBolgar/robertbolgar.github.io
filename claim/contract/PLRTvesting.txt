// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract PLRTVesting is Ownable, ReentrancyGuard {
    IERC20 public plrToken;
    IERC721 public nftToken;
    bool public initialDepositMade = false;
    uint256 public constant TOKENS_PER_NFT = 20_000;
    uint256 public constant WITHDRAWAL_RATE_PER_PERIOD = 10; // 10%
    uint256 public PERIOD_DURATION = 7 days;

    enum VestingGroup { PrivateSale, Team, Treasury }

    struct VestingDetail {
        uint256 totalAllocation;
        uint256 amountWithdrawn;
        uint256 vestingStart;
        VestingGroup group;
    }

    mapping(address => VestingDetail) public vestingDetails;
    mapping(address => bool) public whitelistedAddresses;

    event Withdrawal(address indexed user, uint256 amount);
    event VestingAdded(address indexed user, uint256 allocation, VestingGroup group);
    event InitialDepositMade(uint256 totalAmount, uint256 timestamp);
    event TeamMemberAdded(address indexed member, uint256 allocation);

    constructor(IERC20 _tokenAddress, IERC721 _nftToken) {
        require(address(_tokenAddress) != address(0), "Token address cannot be zero.");
        require(address(_nftToken) != address(0), "NFT token address cannot be zero.");
        plrToken = _tokenAddress;
        nftToken = _nftToken;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender] || nftToken.balanceOf(msg.sender) > 0, "Unauthorized");
        _;
    }

    function addToWhitelist(address _address) external onlyOwner {
        whitelistedAddresses[_address] = true;
    }

    function removeFromWhitelist(address _address) external onlyOwner {
        whitelistedAddresses[_address] = false;
    }

    function initializeTreasuryVesting(uint256 totalAllocation) external onlyOwner {
        require(!initialDepositMade, "Initial deposit already made or treasury already initialized");
        vestingDetails[owner()] = VestingDetail({
            totalAllocation: totalAllocation,
            amountWithdrawn: 0,
            vestingStart: block.timestamp,
            group: VestingGroup.Treasury
        });
        initialDepositMade = true;
    }

    function withdrawTreasuryTokens() external nonReentrant onlyOwner {
        withdrawTokensInternal(msg.sender, VestingGroup.Treasury);
    }

    function withdrawTokens() external nonReentrant onlyWhitelisted {
        withdrawTokensInternal(msg.sender, VestingGroup.PrivateSale);
    }

    function withdrawTokensInternal(address user, VestingGroup group) internal {
        VestingDetail storage detail = vestingDetails[user];
        require(detail.group == group, "Not authorized or wrong group");
        uint256 availableAmount = availableToWithdraw(user);
        require(availableAmount > 0, "No tokens available to withdraw.");
        detail.amountWithdrawn += availableAmount;
        plrToken.transfer(user, availableAmount);
        emit Withdrawal(user, availableAmount);
    }

    function availableToWithdraw(address user) public view returns (uint256) {
        VestingDetail memory detail = vestingDetails[user];
        if (block.timestamp < detail.vestingStart + PERIOD_DURATION) {
            return 0;
        }
        uint256 totalAllocation = detail.group == VestingGroup.PrivateSale ? nftToken.balanceOf(user) * TOKENS_PER_NFT : detail.totalAllocation;
        uint256 timeElapsedSinceVestingStart = block.timestamp - detail.vestingStart;
        uint256 periodsElapsed = timeElapsedSinceVestingStart / PERIOD_DURATION;
        uint256 totalClaimable = totalAllocation * WITHDRAWAL_RATE_PER_PERIOD / 100 * periodsElapsed;
        uint256 availableAmount = totalClaimable > totalAllocation ? totalAllocation - detail.amountWithdrawn : totalClaimable - detail.amountWithdrawn;
        return availableAmount;
    }

    function makeInitialDeposit(uint256 _totalAmount) external onlyOwner {
        require(!initialDepositMade, "Initial deposit already made");
        require(_totalAmount > 0, "Amount must be greater than 0");
        require(plrToken.transferFrom(msg.sender, address(this), _totalAmount), "Token transfer failed");
        initialDepositMade = true;
        emit InitialDepositMade(_totalAmount, block.timestamp);
    }

    function updateVestingPeriod(uint256 _newPeriod) external onlyOwner {
        PERIOD_DURATION = _newPeriod;
    }

    function addTeamMember(address _teamMemberAddress, uint256 _totalAllocation) external onlyOwner {
        require(_teamMemberAddress != address(0), "Invalid team member address");
        require(_totalAllocation > 0, "Allocation must be greater than 0");
        
        vestingDetails[_teamMemberAddress] = VestingDetail({
            totalAllocation: _totalAllocation,
            amountWithdrawn: 0,
            vestingStart: block.timestamp,
            group: VestingGroup.Team
        });
        
        whitelistedAddresses[_teamMemberAddress] = true; // Add team member to whitelist
        emit TeamMemberAdded(_teamMemberAddress, _totalAllocation);
    }
}
